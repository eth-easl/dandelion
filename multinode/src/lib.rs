use ::prost::Message;
use dandelion_commons::{DandelionError, DandelionResult, MultinodeError};
use prost::bytes::Bytes;

pub mod client;

// include autogenerated protobufs
pub mod proto {
    include!(concat!(env!("OUT_DIR"), "/multinode_proto.rs"));
}

// deserialization

pub fn deserialize_action_status(buf: Bytes) -> DandelionResult<proto::ActionStatus> {
    match proto::ActionStatus::decode(buf) {
        Ok(action_status) => Ok(action_status),
        Err(err) => Err(DandelionError::MultinodeError(
            MultinodeError::DeserializationError(format!("{:?}", err)),
        )),
    }
}

pub fn deserialize_node_info(buf: Bytes) -> DandelionResult<proto::NodeInfo> {
    match proto::NodeInfo::decode(buf) {
        Ok(node_info) => Ok(node_info),
        Err(err) => Err(DandelionError::MultinodeError(
            MultinodeError::DeserializationError(format!("{:?}", err)),
        )),
    }
}

pub fn deserialize_task(buf: Bytes) -> DandelionResult<proto::Task> {
    match proto::Task::decode(buf) {
        Ok(node_info) => Ok(node_info),
        Err(err) => Err(DandelionError::MultinodeError(
            MultinodeError::DeserializationError(format!("{:?}", err)),
        )),
    }
}

pub fn deserialize_task_result(buf: Bytes) -> DandelionResult<proto::TaskResult> {
    match proto::TaskResult::decode(buf) {
        Ok(node_info) => Ok(node_info),
        Err(err) => Err(DandelionError::MultinodeError(
            MultinodeError::DeserializationError(format!("{:?}", err)),
        )),
    }
}

// serialization

pub fn serialize_action_status(action_status: proto::ActionStatus) -> Bytes {
    let mut buf = Vec::new();
    buf.reserve(action_status.encoded_len());
    action_status.encode(&mut buf).unwrap();
    Bytes::from(buf)
}

pub fn serialize_node_info(node_info: proto::NodeInfo) -> Bytes {
    let mut buf = Vec::new();
    buf.reserve(node_info.encoded_len());
    node_info.encode(&mut buf).unwrap();
    Bytes::from(buf)
}

pub fn serialize_task(task: proto::Task) -> Bytes {
    let mut buf = Vec::new();
    buf.reserve(task.encoded_len());
    task.encode(&mut buf).unwrap();
    Bytes::from(buf)
}

pub fn serialize_task_result(task_result: proto::TaskResult) -> Bytes {
    let mut buf = Vec::new();
    buf.reserve(task_result.encoded_len());
    task_result.encode(&mut buf).unwrap();
    Bytes::from(buf)
}
